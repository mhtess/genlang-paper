var responseDictionary = { "agree-key": 1, "disagree-key": 0 };
var eps = Number.EPSILON;

var roundTo3 = function(x){
  return Math.round(x * 10000) / 10000
}
var exp = function(x){ return Math.exp(x); };

var probability = function(Dist, x) {
    return exp(Dist.score(x));
}

// DECIDE: Currently, lowest non-0 rate is 1/"5 years"
// lowest in expt: 3 / "5 years" (do we need to go so low?)
// var lowerBound = -2, upperBound = 6, binWidth = 0.4;
var lowerBound = -5, upperBound = 10, binWidth = 0.5;

// scale: number of times / year
// var upperBins = map(
// 	function(i){ Math.exp(i) / 5},
// 	_.range(lowerBound, upperBound, binWidth))

// var upperBins = [0.2, 0.6, 1, 1.5, 3, 6, 12, 18, 24, 36, 52, 78, 104, 156, 208, 260, 365]

// var upperBins = map(exp, _.range(lowerBound, upperBound, binWidth))
// var lowerBins = [0].concat(upperBins.slice(0, upperBins.length - 1))

var upperBins =  _.range(
  lowerBound, upperBound, binWidth
)
var lowerBins = [lowerBound - binWidth].concat(
  upperBins.slice(0, upperBins.length - 1)
)


// for FF prior
// var upperBins = _.range(lowerBound + binWidth, upperBound + binWidth, binWidth);
// var lowerBins = [lowerBound].concat(upperBins.slice(0, upperBins.length - 1))

var midBins = map2(function(b1,b2){
  var diff = Math.abs(b2 - b1) / 2;
  return roundTo3(b1 + diff)
}, lowerBins, upperBins)

var thetaBins = map2(function(b1, b2){
  var diff = Math.abs(b2 - b1) / 2;
  return roundTo3(diff+ b1);
}, midBins.slice(0, midBins.length-1), midBins.slice(1))


var DiscretizedLognormal = function(gaussianParams){
	return Infer({model: function(){
    return categorical({
      vs: midBins,
      ps: map2(function(b1, b2){
        return eps +
        utils.lognormalCDF(b2, gaussianParams) -
        utils.lognormalCDF(b1, gaussianParams)
      }, lowerBins, upperBins)
    })
  }})
}

var DiscretizedGaussian = function(gaussianParams){
	return Infer({model: function(){
    return categorical({
      vs: midBins,
      ps: map2(function(b1, b2){
        return eps +
        utils.gaussianCDF(b2, gaussianParams) -
        utils.gaussianCDF(b1, gaussianParams)
      }, lowerBins, upperBins)
    })
  }})
}


var thetaPrior = Infer({model: function(){
  var uniformParams = {a:_.min(midBins),b:_.max(midBins)};
    return categorical({
          vs: thetaBins,
          ps: map2(function(b1, b2){
            return utils.uniformCDF(b2, uniformParams) -
                   utils.uniformCDF(b1, uniformParams)
          }, midBins.slice(0, midBins.length-1),
            midBins.slice(1))
        })
}})

// var thetaPrior = Infer({model: function(){
//   return uniformDraw(thetaBins)
// }})

var betaShape = function(p){
  return {a: p.g * p.d, b: (1-p.g) * p.d}
};


var avoidEnds = function(response){
    return response==0 ? 0.0001 : response==1 ? 0.9999 : response
}

var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var levels = function(df, label){
  return _.uniqBy(_.map(df, label));
}

var distProbs = function(dist, supp) {
  return map(function(s) {
    return Math.exp(dist.score(s))
  }, supp)
}

var KL = function(p, q, supp) {
  var P = distProbs(p, supp), Q = distProbs(q, supp);
  var diverge = function(xp,xq) {
    return xp == 0 ? 0 : (xp * Math.log(xp / xq) );
  };
  return sum(map2(diverge,P,Q));
};

var marginalize = function(myDist, label){
    Infer({method: "enumerate"}, function(){
        var x = sample(myDist);
        return x[label]
    });
};

var dataFrame = function(d, fieldsToNumerify){
    return map(
        function(lst){
            return _.fromPairs(map(function(l){
                return _.indexOf(fieldsToNumerify, l[0]) > -1 ?
                            [l[0], utils.wpParseFloat(l[1])] : l
            },
            _.zip(d[0],lst)
            ))
        },
        d.slice(1))
}

var removeExtraRow = function(lst){
  return lst.slice(0, lst.length - 1)
}

var displayObj = function(x){ display(JSON.stringify(x)) }
